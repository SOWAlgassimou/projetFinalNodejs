Le projet "Gestion des Tâches d'une Équipe" est un excellent exercice pour mettre en pratique Node.js, Express, MongoDB et JWT.
Voici un plan de travail clair avec structure de code et explications détaillées pour que tu puisses le développer, tester et déployer dans les délais.

1️⃣ Structure du projet
gestion-taches/
│── config/
│    └── db.js                # Connexion à MongoDB
│
│── models/
│    ├── User.js               # Modèle utilisateur
│    └── Task.js               # Modèle tâche
│
│── routes/
│    ├── auth.routes.js        # Routes inscription / connexion
│    ├── user.routes.js        # Routes gestion membres
│    └── task.routes.js        # Routes gestion tâches
│
│── middleware/
│    └── authMiddleware.js     # Vérification JWT
│
│── controllers/
│    ├── auth.controller.js
│    ├── user.controller.js
│    └── task.controller.js
│
│── server.js                  # Point d’entrée du serveur
│── package.json
│── .env                       # Variables d’environnement

2️⃣ Étapes de développement
Jour 1 : Authentification & Gestion des utilisateurs

Installer les dépendances :

npm init -y
npm install express mongoose bcryptjs jsonwebtoken dotenv cors
npm install nodemon --save-dev


Connexion MongoDB Atlas (config/db.js)

const mongoose = require('mongoose');

const connectDB = async () => {
  try {
    await mongoose.connect(process.env.MONGO_URI, { useNewUrlParser: true, useUnifiedTopology: true });
    console.log('✅ MongoDB connecté');
  } catch (error) {
    console.error('❌ Erreur MongoDB :', error.message);
    process.exit(1);
  }
};

module.exports = connectDB;


Modèle utilisateur (models/User.js)

const mongoose = require('mongoose');

const userSchema = new mongoose.Schema({
  nom: { type: String, required: true },
  email: { type: String, required: true, unique: true },
  motdepasse: { type: String, required: true }
}, { timestamps: true });

module.exports = mongoose.model('User', userSchema);


Contrôleur Auth (controllers/auth.controller.js)

const User = require('../models/User');
const bcrypt = require('bcryptjs');
const jwt = require('jsonwebtoken');

// Inscription
exports.signup = async (req, res) => {
  try {
    const { nom, email, motdepasse } = req.body;
    const hashedPassword = await bcrypt.hash(motdepasse, 10);
    const newUser = new User({ nom, email, motdepasse: hashedPassword });
    await newUser.save();
    res.json({ message: "Utilisateur créé avec succès" });
  } catch (error) {
    res.status(500).json({ error: error.message });
  }
};

// Connexion
exports.login = async (req, res) => {
  try {
    const { email, motdepasse } = req.body;
    const user = await User.findOne({ email });
    if (!user) return res.status(404).json({ message: "Utilisateur non trouvé" });

    const isMatch = await bcrypt.compare(motdepasse, user.motdepasse);
    if (!isMatch) return res.status(400).json({ message: "Mot de passe incorrect" });

    const token = jwt.sign({ id: user._id }, process.env.JWT_SECRET, { expiresIn: "1d" });
    res.json({ token });
  } catch (error) {
    res.status(500).json({ error: error.message });
  }
};


Middleware Auth (middleware/authMiddleware.js)

const jwt = require('jsonwebtoken');

module.exports = function (req, res, next) {
  const token = req.header('Authorization');
  if (!token) return res.status(401).json({ message: "Accès refusé" });

  try {
    const verified = jwt.verify(token, process.env.JWT_SECRET);
    req.user = verified;
    next();
  } catch (err) {
    res.status(400).json({ message: "Token invalide" });
  }
};

Jour 2 : Gestion des tâches

Modèle Tâche (models/Task.js)

const mongoose = require('mongoose');

const taskSchema = new mongoose.Schema({
  titre: { type: String, required: true },
  description: String,
  priorite: { type: String, enum: ["Haute", "Moyenne", "Basse"], default: "Moyenne" },
  statut: { type: String, enum: ["En cours", "Terminée"], default: "En cours" },
  assignee: { type: mongoose.Schema.Types.ObjectId, ref: 'User' }
}, { timestamps: true });

module.exports = mongoose.model('Task', taskSchema);


Contrôleur Tâches (controllers/task.controller.js)

const Task = require('../models/Task');

// Ajouter une tâche
exports.createTask = async (req, res) => {
  try {
    const task = new Task(req.body);
    await task.save();
    res.json(task);
  } catch (error) {
    res.status(500).json({ error: error.message });
  }
};

// Lire avec pagination
exports.getTasks = async (req, res) => {
  try {
    const { page = 1, limit = 5, priorite, statut } = req.query;
    let filter = {};
    if (priorite) filter.priorite = priorite;
    if (statut) filter.statut = statut;

    const tasks = await Task.find(filter)
      .populate("assignee", "nom email")
      .limit(parseInt(limit))
      .skip((page - 1) * limit);

    res.json(tasks);
  } catch (error) {
    res.status(500).json({ error: error.message });
  }
};

// Modifier / Supprimer
exports.updateTask = async (req, res) => {
  try {
    const task = await Task.findByIdAndUpdate(req.params.id, req.body, { new: true });
    res.json(task);
  } catch (error) {
    res.status(500).json({ error: error.message });
  }
};

exports.deleteTask = async (req, res) => {
  try {
    await Task.findByIdAndDelete(req.params.id);
    res.json({ message: "Tâche supprimée" });
  } catch (error) {
    res.status(500).json({ error: error.message });
  }
};

Jour 3 : Tests

Utiliser Postman pour tester chaque route.

Scénarios :

✅ Inscription & connexion (récupérer token)

✅ CRUD Tâches avec authentification

✅ Pagination et filtres

✅ Gestion des erreurs

Jour 4 : Déploiement

Créer une base MongoDB Atlas

Déployer sur Render ou Heroku

Variables .env :

MONGO_URI=...
JWT_SECRET=monsecret
PORT=5000


💡 Si tu veux, je peux te préparer tout le projet complet prêt à exécuter avec commentaires ligne par ligne pour que tu n’aies plus qu’à le personnaliser et déployer.
Veux-tu que je te fasse la version clé en main ?

Vous avez dit :
Ok veillez me préparer tout le projet au complet prêt à exécuter avec commentaires ligne par ligne mais ajouter aussi les validateurs avec joi ok !
ChatGPT a dit :

Super — je te fournis le projet complet, prêt à exécuter, avec Joi pour la validation, JWT pour l’authentification, bcrypt pour le hachage des mots de passe, une architecture claire (models / controllers / routes / middlewares / validators), et commentaires ligne par ligne pour que tu puisses tout comprendre.

✅ Ce que tu vas recevoir ici : tous les fichiers essentiels (contenu à copier dans ton projet).
✅ Après avoir copié les fichiers, je te donne les commandes pour installer et lancer localement, puis un rappel pour le déploiement sur Render / Atlas.

Arborescence recommandée (copie-colle)
gestion-taches/
├─ config/
│  └─ db.js
├─ controllers/
│  ├─ auth.controller.js
│  ├─ user.controller.js
│  └─ task.controller.js
├─ middleware/
│  ├─ auth.middleware.js
│  └─ error.middleware.js
├─ models/
│  ├─ User.js
│  └─ Task.js
├─ routes/
│  ├─ auth.routes.js
│  ├─ user.routes.js
│  └─ task.routes.js
├─ validators/
│  ├─ auth.validator.js
│  └─ task.validator.js
├─ .env.example
├─ package.json
├─ README.md
└─ server.js


Important : crée un dossier gestion-taches, puis crée les fichiers suivants avec exactement ce contenu.

1) package.json

Crée ce fichier à la racine.

{
  "name": "gestion-taches",
  "version": "1.0.0",
  "description": "API Gestion des Tâches d'une Équipe (Node.js, Express, MongoDB, JWT, Joi)",
  "main": "server.js",
  "scripts": {
    "dev": "nodemon server.js",
    "start": "node server.js"
  },
  "keywords": [],
  "author": "",
  "license": "MIT",
  "dependencies": {
    "bcryptjs": "^2.4.3",
    "cors": "^2.8.5",
    "dotenv": "^16.4.5",
    "express": "^4.18.2",
    "helmet": "^7.1.0",
    "joi": "^17.13.3",
    "jsonwebtoken": "^9.0.0",
    "mongoose": "^8.5.2",
    "morgan": "^1.10.0"
  },
  "devDependencies": {
    "nodemon": "^3.1.4"
  }
}

2) .env.example

Copie ce fichier en .env et remplace par tes valeurs (ne pas commiter .env).

PORT=5000
MONGO_URI=mongodb+srv://<USER>:<PASSWORD>@cluster0.example.mongodb.net/gestion_taches?retryWrites=true&w=majority
JWT_SECRET=ta_cle_secrete_très_longue
TOKEN_EXPIRES_IN=1d
CORS_ORIGIN=*

3) config/db.js

Connexion Mongoose centralisée.

// config/db.js
// Fichier central pour se connecter à MongoDB via mongoose.

const mongoose = require('mongoose');

/**
 * connectDB: se connecte à la base MongoDB.
 * @param {string} uri - chaîne de connexion MongoDB (depuis .env)
 */
async function connectDB(uri) {
  try {
    // mongoose.connect retourne une promesse ; on attend la connexion
    await mongoose.connect(uri);
    console.log('✅ MongoDB connecté');
  } catch (err) {
    // Si échec de connexion, on affiche et on arrête l'application
    console.error('❌ Erreur de connexion MongoDB :', err.message);
    process.exit(1);
  }
}

module.exports = { connectDB };

4) models/User.js

Modèle utilisateur (nom, email unique, mot de passe haché, rôle).

// models/User.js
// Schéma Mongoose pour les utilisateurs

const mongoose = require('mongoose');

const userSchema = new mongoose.Schema({
  nom: {
    type: String,
    required: true,
    trim: true
  },
  email: {
    type: String,
    required: true,
    unique: true,   // Email unique
    lowercase: true,
    trim: true
  },
  motdepasse: {
    type: String,
    required: true
  },
  role: {
    type: String,
    enum: ['membre', 'admin'],
    default: 'membre'
  }
}, { timestamps: true });

// Export du modèle : 'User' -> collection 'users'
module.exports = mongoose.model('User', userSchema);

5) models/Task.js

Modèle tâche avec référence à l'assignee (utilisateur).

// models/Task.js
// Schéma Mongoose pour les tâches

const mongoose = require('mongoose');

const taskSchema = new mongoose.Schema({
  titre: {
    type: String,
    required: true,
    trim: true
  },
  description: {
    type: String,
    default: '',
    trim: true
  },
  priorite: {
    type: String,
    enum: ['Haute', 'Moyenne', 'Basse'],
    default: 'Moyenne'
  },
  statut: {
    type: String,
    enum: ['En cours', 'Terminée'],
    default: 'En cours'
  },
  assignee: {
    type: mongoose.Schema.Types.ObjectId,
    ref: 'User',   // Référence au modèle User
    default: null
  },
  dateEcheance: {
    type: Date,
    default: null
  }
}, { timestamps: true });

module.exports = mongoose.model('Task', taskSchema);

6) validators/auth.validator.js

Validation Joi pour signup/login.

// validators/auth.validator.js
// Contient les schémas Joi pour l'inscription et la connexion

const Joi = require('joi');

// Schéma pour l'inscription
const signupSchema = Joi.object({
  nom: Joi.string().min(2).max(100).required().messages({
    'string.base': 'Le nom doit être une chaîne',
    'string.empty': 'Le nom est requis',
    'string.min': 'Le nom doit faire au moins {#limit} caractères',
  }),
  email: Joi.string().email().required().messages({
    'string.email': 'Email invalide',
    'string.empty': 'Email est requis'
  }),
  motdepasse: Joi.string().min(6).required().messages({
    'string.min': 'Le mot de passe doit contenir au moins {#limit} caractères'
  })
});

// Schéma pour la connexion
const loginSchema = Joi.object({
  email: Joi.string().email().required(),
  motdepasse: Joi.string().required()
});

module.exports = { signupSchema, loginSchema };

7) validators/task.validator.js

Validation Joi pour créer / mettre à jour une tâche.

// validators/task.validator.js
// Schémas Joi pour créer / mettre à jour une tâche

const Joi = require('joi');

// Schéma création (titre requis)
const createTaskSchema = Joi.object({
  titre: Joi.string().min(2).max(200).required(),
  description: Joi.string().allow('').max(2000),
  priorite: Joi.string().valid('Haute', 'Moyenne', 'Basse'),
  statut: Joi.string().valid('En cours', 'Terminée'),
  assignee: Joi.string().hex().length(24).allow(null), // ObjectId ou null
  dateEcheance: Joi.date().iso().allow(null)
});

// Schéma update : au moins 1 champ
const updateTaskSchema = Joi.object({
  titre: Joi.string().min(2).max(200),
  description: Joi.string().allow('').max(2000),
  priorite: Joi.string().valid('Haute', 'Moyenne', 'Basse'),
  statut: Joi.string().valid('En cours', 'Terminée'),
  assignee: Joi.string().hex().length(24).allow(null),
  dateEcheance: Joi.date().iso().allow(null)
}).min(1);

module.exports = { createTaskSchema, updateTaskSchema };

8) controllers/auth.controller.js

Signup & login avec bcrypt + JWT. Commentaires ligne par ligne.

// controllers/auth.controller.js
// Contrôleur pour l'inscription et la connexion

const User = require('../models/User');
const bcrypt = require('bcryptjs');
const jwt = require('jsonwebtoken');
const { signupSchema, loginSchema } = require('../validators/auth.validator');

// INSCRIPTION
exports.signup = async (req, res, next) => {
  try {
    // 1) Validation des données reçues
    const { error, value } = signupSchema.validate(req.body);
    if (error) {
      // Joi fournit details ; on renvoie 400
      return res.status(400).json({ message: error.details.map(d => d.message).join(' | ') });
    }

    const { nom, email, motdepasse } = value;

    // 2) Vérifier si l'email existe déjà
    const existing = await User.findOne({ email });
    if (existing) return res.status(400).json({ message: 'Email déjà utilisé' });

    // 3) Hacher le mot de passe (sécurité)
    const salt = await bcrypt.genSalt(10);
    const hashed = await bcrypt.hash(motdepasse, salt);

    // 4) Créer l'utilisateur et le sauvegarder
    const user = new User({ nom, email, motdepasse: hashed });
    await user.save();

    // 5) Réponse : 201 Created
    res.status(201).json({ message: 'Utilisateur créé', user: { id: user._id, nom: user.nom, email: user.email } });
  } catch (err) {
    next(err); // passage au middleware d'erreur
  }
};

// CONNEXION
exports.login = async (req, res, next) => {
  try {
    // 1) Validation
    const { error, value } = loginSchema.validate(req.body);
    if (error) return res.status(400).json({ message: error.details.map(d => d.message).join(' | ') });

    const { email, motdepasse } = value;

    // 2) Recherche utilisateur
    const user = await User.findOne({ email });
    if (!user) return res.status(400).json({ message: 'Email ou mot de passe invalide' });

    // 3) Vérifier mot de passe
    const isValid = await bcrypt.compare(motdepasse, user.motdepasse);
    if (!isValid) return res.status(400).json({ message: 'Email ou mot de passe invalide' });

    // 4) Générer token JWT (payload minimal)
    const payload = { id: user._id, role: user.role };
    const token = jwt.sign(payload, process.env.JWT_SECRET, { expiresIn: process.env.TOKEN_EXPIRES_IN || '1d' });

    // 5) Répondre avec token
    res.json({ message: 'Connexion réussie', token });
  } catch (err) {
    next(err);
  }
};

9) controllers/user.controller.js

Gestion des membres (liste, détail, supprimer). Protégée par auth middleware (admin check optional).

// controllers/user.controller.js
const User = require('../models/User');

/**
 * Lister tous les utilisateurs
 * (dans une app réelle, restreindre cette route aux admins)
 */
exports.listUsers = async (req, res, next) => {
  try {
    const users = await User.find().select('-motdepasse').sort({ createdAt: -1 });
    res.json(users);
  } catch (err) {
    next(err);
  }
};

// Récupérer un utilisateur par id
exports.getUserById = async (req, res, next) => {
  try {
    const u = await User.findById(req.params.id).select('-motdepasse');
    if (!u) return res.status(404).json({ message: 'Utilisateur non trouvé' });
    res.json(u);
  } catch (err) {
    next(err);
  }
};

// Supprimer un utilisateur (attention : en prod, vérifier droits)
exports.deleteUser = async (req, res, next) => {
  try {
    const deleted = await User.findByIdAndDelete(req.params.id);
    if (!deleted) return res.status(404).json({ message: 'Utilisateur non trouvé' });
    res.json({ message: 'Utilisateur supprimé' });
  } catch (err) {
    next(err);
  }
};

10) controllers/task.controller.js

CRUD tâches + pagination + filtres (priorité / statut) + assignation. Commentaires détaillés.

// controllers/task.controller.js
const Task = require('../models/Task');
const { createTaskSchema, updateTaskSchema } = require('../validators/task.validator');
const mongoose = require('mongoose');

/**
 * Créer une tâche
 * POST /api/tasks
 */
exports.createTask = async (req, res, next) => {
  try {
    // Validation Joi
    const { error, value } = createTaskSchema.validate(req.body);
    if (error) return res.status(400).json({ message: error.details.map(d => d.message).join(' | ') });

    // On peut associer le créateur si on le souhaite : req.user.id
    const task = new Task(value);
    await task.save();

    res.status(201).json(task);
  } catch (err) {
    next(err);
  }
};

/**
 * Lister les tâches avec pagination et filtres
 * GET /api/tasks?page=1&limit=10&priorite=Haute&statut=En%20cours&assignee=ID
 */
exports.getTasks = async (req, res, next) => {
  try {
    // Paramètres de query
    let { page = 1, limit = 10, priorite, statut, assignee, sortBy = 'createdAt', order = 'desc' } = req.query;
    page = parseInt(page);
    limit = Math.min(parseInt(limit), 100); // safeguard
    const skip = (page - 1) * limit;
    const sortOrder = order === 'asc' ? 1 : -1;

    // Construction du filtre dynamique
    const filter = {};
    if (priorite) filter.priorite = priorite;
    if (statut) filter.statut = statut;
    if (assignee && mongoose.Types.ObjectId.isValid(assignee)) filter.assignee = assignee;

    // Exécution des requêtes en parallèle
    const [items, total] = await Promise.all([
      Task.find(filter)
        .populate('assignee', 'nom email')      // remplace assignee par document user minimal
        .sort({ [sortBy]: sortOrder })
        .skip(skip)
        .limit(limit),
      Task.countDocuments(filter)
    ]);

    res.json({
      meta: {
        page,
        limit,
        total,
        totalPages: Math.ceil(total / limit)
      },
      data: items
    });
  } catch (err) {
    next(err);
  }
};

/**
 * Récupérer une tâche par id
 */
exports.getTaskById = async (req, res, next) => {
  try {
    const t = await Task.findById(req.params.id).populate('assignee', 'nom email');
    if (!t) return res.status(404).json({ message: 'Tâche non trouvée' });
    res.json(t);
  } catch (err) {
    next(err);
  }
};

/**
 * Mettre à jour une tâche
 * PUT /api/tasks/:id
 */
exports.updateTask = async (req, res, next) => {
  try {
    // Validation Joi (au moins 1 champ)
    const { error, value } = updateTaskSchema.validate(req.body);
    if (error) return res.status(400).json({ message: error.details.map(d => d.message).join(' | ') });

    const updated = await Task.findByIdAndUpdate(req.params.id, value, { new: true, runValidators: true });
    if (!updated) return res.status(404).json({ message: 'Tâche non trouvée' });
    res.json(updated);
  } catch (err) {
    next(err);
  }
};

/**
 * Supprimer une tâche
 */
exports.deleteTask = async (req, res, next) => {
  try {
    const deleted = await Task.findByIdAndDelete(req.params.id);
    if (!deleted) return res.status(404).json({ message: 'Tâche non trouvée' });
    res.json({ message: 'Tâche supprimée' });
  } catch (err) {
    next(err);
  }
};

11) middleware/auth.middleware.js

Vérifie le token JWT et injecte req.user. On peut ajouter contrôle de role.

// middleware/auth.middleware.js
// Middleware pour protéger les routes nécessitant une authentification

const jwt = require('jsonwebtoken');

/**
 * authMiddleware - vérifie présence et validité d'un JWT dans Authorization header
 * Header attendu : Authorization: Bearer <token>
 */
module.exports = function (req, res, next) {
  // Récupère le header Authorization
  const authHeader = req.header('Authorization');
  if (!authHeader) return res.status(401).json({ message: 'Token manquant' });

  // Support "Bearer token" ou juste token
  const token = authHeader.startsWith('Bearer ') ? authHeader.split(' ')[1] : authHeader;

  if (!token) return res.status(401).json({ message: 'Token manquant' });

  try {
    // Vérifie le token et récupère le payload
    const decoded = jwt.verify(token, process.env.JWT_SECRET);
    req.user = decoded; // ex: { id: ..., role: ... }
    next();
  } catch (err) {
    return res.status(401).json({ message: 'Token invalide' });
  }
};

12) middleware/error.middleware.js

Gestion d’erreurs centralisée.

// middleware/error.middleware.js

module.exports = function (err, req, res, next) {
  console.error('Erreur attrapée :', err.message);
  const status = err.status || 500;
  res.status(status).json({
    success: false,
    message: err.message || 'Erreur serveur'
  });
};

13) routes/auth.routes.js

Routes signup & login.

// routes/auth.routes.js
const express = require('express');
const router = express.Router();
const authCtrl = require('../controllers/auth.controller');

// POST /api/auth/signup
router.post('/signup', authCtrl.signup);

// POST /api/auth/login
router.post('/login', authCtrl.login);

module.exports = router;

14) routes/user.routes.js

Gestion membres (protégée).

// routes/user.routes.js
const express = require('express');
const router = express.Router();
const userCtrl = require('../controllers/user.controller');
const auth = require('../middleware/auth.middleware');

// Toutes ces routes nécessitent d'être authentifié (token)
router.get('/', auth, userCtrl.listUsers);
router.get('/:id', auth, userCtrl.getUserById);
router.delete('/:id', auth, userCtrl.deleteUser);

module.exports = router;

15) routes/task.routes.js

Routes tâches (protéger selon besoin).

// routes/task.routes.js
const express = require('express');
const router = express.Router();
const taskCtrl = require('../controllers/task.controller');
const auth = require('../middleware/auth.middleware');

// Protection : toutes les routes nécessitent un token
router.post('/', auth, taskCtrl.createTask);
router.get('/', auth, taskCtrl.getTasks);
router.get('/:id', auth, taskCtrl.getTaskById);
router.put('/:id', auth, taskCtrl.updateTask);
router.delete('/:id', auth, taskCtrl.deleteTask);

module.exports = router;

16) server.js

Point d’entrée : configuration, middlewares globaux, routes, connexion DB, démarrage.

// server.js
// Point d'entrée de l'application

require('dotenv').config();            // charge .env
const express = require('express');
const helmet = require('helmet');      // sécurité headers
const cors = require('cors');          // gestion CORS
const morgan = require('morgan');      // logs HTTP

const { connectDB } = require('./config/db');
const errorHandler = require('./middleware/error.middleware');

// Routes
const authRoutes = require('./routes/auth.routes');
const userRoutes = require('./routes/user.routes');
const taskRoutes = require('./routes/task.routes');

const app = express();

// Middlewares globaux
app.use(helmet());
app.use(cors({ origin: process.env.CORS_ORIGIN || '*' })); // limiter en prod
app.use(morgan('dev'));
app.use(express.json()); // parse application/json

// Routes principales (préfixées)
app.use('/api/auth', authRoutes);
app.use('/api/users', userRoutes);
app.use('/api/tasks', taskRoutes);

// 404 si route non trouvée
app.use((req, res, next) => {
  res.status(404).json({ message: `Route ${req.originalUrl} introuvable` });
});

// Middleware gestion d'erreurs centralisé
app.use(errorHandler);

// Connexion DB puis démarrage du serveur
const PORT = process.env.PORT || 5000;
connectDB(process.env.MONGO_URI).then(() => {
  app.listen(PORT, () => {
    console.log(`🚀 Serveur démarré sur http://localhost:${PORT}`);
  });
});

17) README.md (exécution locale & déploiement bref)

Crée un README pour instructions rapides.

# Gestion Tâches (API)

## Installation locale

1. Cloner le repo ou copier les fichiers.
2. `cd gestion-taches`
3. `npm install`
4. Copier `.env.example` en `.env` et remplir `MONGO_URI`, `JWT_SECRET`, etc.
5. Lancer en dev :


npm run dev

L'API écoute sur `http://localhost:5000` (si PORT=5000).

## Endpoints principaux

- `POST /api/auth/signup` - body: { nom, email, motdepasse }
- `POST /api/auth/login` - body: { email, motdepasse } -> renvoie token
- `GET /api/tasks` - liste paginée/filter (requiert header Authorization)
- `POST /api/tasks` - créer tâche (requiert token)
- `PUT /api/tasks/:id` - modifier
- `DELETE /api/tasks/:id` - supprimer
- `GET /api/users` - lister les utilisateurs (requiert token)

## Déploiement (bref)
1. Créer cluster MongoDB Atlas et récupérer `MONGO_URI`.
2. Push sur GitHub.
3. Créer un service Web sur Render :
   - Build: `npm install`
   - Start: `npm start`
   - Add Environment variables (MONGO_URI, JWT_SECRET, PORT, CORS_ORIGIN)
4. Déployer et tester l'URL fournie par Render.

> Note : pour les images/fichiers en prod, évite stockage local ; utiliser S3/Cloudinary.

✅ Etapes pour lancer localement (récapitulatif)

Crée dossier gestion-taches et tous les fichiers ci-dessus.

cd gestion-taches

npm install

Copie .env.example → .env puis complète avec ta chaîne MONGO_URI (Atlas) et JWT_SECRET.

Lancer en dev :

npm run dev


Tester avec Postman / Thunder Client :

Inscription : POST /api/auth/signup body JSON { "nom": "Alice", "email": "a@x.com", "motdepasse": "secret" }

Connexion : POST /api/auth/login body { "email": "...", "motdepasse": "..." } → récupère token

Utiliser header Authorization: Bearer <token> pour routes protégées.

✅ Tests rapides (exemples Postman)

Inscription

URL: POST http://localhost:5000/api/auth/signup

Body JSON:

{ "nom": "Jean", "email": "jean@example.com", "motdepasse": "azerty123" }


Connexion

URL: POST http://localhost:5000/api/auth/login

Body JSON:

{ "email": "jean@example.com", "motdepasse": "azerty123" }


Réponse : { message: 'Connexion réussie', token: '...' }

Créer Tâche

URL: POST http://localhost:5000/api/tasks

Headers: Authorization: Bearer <token>

Body JSON:

{ "titre": "Préparer réunion", "description": "Préparer slides", "priorite": "Haute" }


Lister tâches (pagination et filtres)

URL: GET http://localhost:5000/api/tasks?page=1&limit=10&priorite=Haute&statut=En%20cours

Si tu veux, je peux générer un archive ZIP prêt à télécharger (si tu veux que je l’envoie ici je peux te fournir le contenu via steps), ou je peux directement ajouter l’auth + rôle admin (par ex : empêcher suppression d’utilisateur sauf admin), ou ajouter tests avec Jest/Supertest.

Dis-moi :

Tu veux que j’ajoute la vérification isAdmin pour certaines routes ?

Tu veux que j’intègre l’upload (ex : pièce jointe pour tâche) maintenant ?

Ou on passe directement au déploiement Render + Atlas ensemble (je te guide étape par étape) ?

ChatGPT peut faire des erreurs. Envisagez de vér