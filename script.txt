Le projet "Gestion des TÃ¢ches d'une Ã‰quipe" est un excellent exercice pour mettre en pratique Node.js, Express, MongoDB et JWT.
Voici un plan de travail clair avec structure de code et explications dÃ©taillÃ©es pour que tu puisses le dÃ©velopper, tester et dÃ©ployer dans les dÃ©lais.

1ï¸âƒ£ Structure du projet
gestion-taches/
â”‚â”€â”€ config/
â”‚    â””â”€â”€ db.js                # Connexion Ã  MongoDB
â”‚
â”‚â”€â”€ models/
â”‚    â”œâ”€â”€ User.js               # ModÃ¨le utilisateur
â”‚    â””â”€â”€ Task.js               # ModÃ¨le tÃ¢che
â”‚
â”‚â”€â”€ routes/
â”‚    â”œâ”€â”€ auth.routes.js        # Routes inscription / connexion
â”‚    â”œâ”€â”€ user.routes.js        # Routes gestion membres
â”‚    â””â”€â”€ task.routes.js        # Routes gestion tÃ¢ches
â”‚
â”‚â”€â”€ middleware/
â”‚    â””â”€â”€ authMiddleware.js     # VÃ©rification JWT
â”‚
â”‚â”€â”€ controllers/
â”‚    â”œâ”€â”€ auth.controller.js
â”‚    â”œâ”€â”€ user.controller.js
â”‚    â””â”€â”€ task.controller.js
â”‚
â”‚â”€â”€ server.js                  # Point dâ€™entrÃ©e du serveur
â”‚â”€â”€ package.json
â”‚â”€â”€ .env                       # Variables dâ€™environnement

2ï¸âƒ£ Ã‰tapes de dÃ©veloppement
Jour 1 : Authentification & Gestion des utilisateurs

Installer les dÃ©pendances :

npm init -y
npm install express mongoose bcryptjs jsonwebtoken dotenv cors
npm install nodemon --save-dev


Connexion MongoDB Atlas (config/db.js)

const mongoose = require('mongoose');

const connectDB = async () => {
  try {
    await mongoose.connect(process.env.MONGO_URI, { useNewUrlParser: true, useUnifiedTopology: true });
    console.log('âœ… MongoDB connectÃ©');
  } catch (error) {
    console.error('âŒ Erreur MongoDB :', error.message);
    process.exit(1);
  }
};

module.exports = connectDB;


ModÃ¨le utilisateur (models/User.js)

const mongoose = require('mongoose');

const userSchema = new mongoose.Schema({
  nom: { type: String, required: true },
  email: { type: String, required: true, unique: true },
  motdepasse: { type: String, required: true }
}, { timestamps: true });

module.exports = mongoose.model('User', userSchema);


ContrÃ´leur Auth (controllers/auth.controller.js)

const User = require('../models/User');
const bcrypt = require('bcryptjs');
const jwt = require('jsonwebtoken');

// Inscription
exports.signup = async (req, res) => {
  try {
    const { nom, email, motdepasse } = req.body;
    const hashedPassword = await bcrypt.hash(motdepasse, 10);
    const newUser = new User({ nom, email, motdepasse: hashedPassword });
    await newUser.save();
    res.json({ message: "Utilisateur crÃ©Ã© avec succÃ¨s" });
  } catch (error) {
    res.status(500).json({ error: error.message });
  }
};

// Connexion
exports.login = async (req, res) => {
  try {
    const { email, motdepasse } = req.body;
    const user = await User.findOne({ email });
    if (!user) return res.status(404).json({ message: "Utilisateur non trouvÃ©" });

    const isMatch = await bcrypt.compare(motdepasse, user.motdepasse);
    if (!isMatch) return res.status(400).json({ message: "Mot de passe incorrect" });

    const token = jwt.sign({ id: user._id }, process.env.JWT_SECRET, { expiresIn: "1d" });
    res.json({ token });
  } catch (error) {
    res.status(500).json({ error: error.message });
  }
};


Middleware Auth (middleware/authMiddleware.js)

const jwt = require('jsonwebtoken');

module.exports = function (req, res, next) {
  const token = req.header('Authorization');
  if (!token) return res.status(401).json({ message: "AccÃ¨s refusÃ©" });

  try {
    const verified = jwt.verify(token, process.env.JWT_SECRET);
    req.user = verified;
    next();
  } catch (err) {
    res.status(400).json({ message: "Token invalide" });
  }
};

Jour 2 : Gestion des tÃ¢ches

ModÃ¨le TÃ¢che (models/Task.js)

const mongoose = require('mongoose');

const taskSchema = new mongoose.Schema({
  titre: { type: String, required: true },
  description: String,
  priorite: { type: String, enum: ["Haute", "Moyenne", "Basse"], default: "Moyenne" },
  statut: { type: String, enum: ["En cours", "TerminÃ©e"], default: "En cours" },
  assignee: { type: mongoose.Schema.Types.ObjectId, ref: 'User' }
}, { timestamps: true });

module.exports = mongoose.model('Task', taskSchema);


ContrÃ´leur TÃ¢ches (controllers/task.controller.js)

const Task = require('../models/Task');

// Ajouter une tÃ¢che
exports.createTask = async (req, res) => {
  try {
    const task = new Task(req.body);
    await task.save();
    res.json(task);
  } catch (error) {
    res.status(500).json({ error: error.message });
  }
};

// Lire avec pagination
exports.getTasks = async (req, res) => {
  try {
    const { page = 1, limit = 5, priorite, statut } = req.query;
    let filter = {};
    if (priorite) filter.priorite = priorite;
    if (statut) filter.statut = statut;

    const tasks = await Task.find(filter)
      .populate("assignee", "nom email")
      .limit(parseInt(limit))
      .skip((page - 1) * limit);

    res.json(tasks);
  } catch (error) {
    res.status(500).json({ error: error.message });
  }
};

// Modifier / Supprimer
exports.updateTask = async (req, res) => {
  try {
    const task = await Task.findByIdAndUpdate(req.params.id, req.body, { new: true });
    res.json(task);
  } catch (error) {
    res.status(500).json({ error: error.message });
  }
};

exports.deleteTask = async (req, res) => {
  try {
    await Task.findByIdAndDelete(req.params.id);
    res.json({ message: "TÃ¢che supprimÃ©e" });
  } catch (error) {
    res.status(500).json({ error: error.message });
  }
};

Jour 3 : Tests

Utiliser Postman pour tester chaque route.

ScÃ©narios :

âœ… Inscription & connexion (rÃ©cupÃ©rer token)

âœ… CRUD TÃ¢ches avec authentification

âœ… Pagination et filtres

âœ… Gestion des erreurs

Jour 4 : DÃ©ploiement

CrÃ©er une base MongoDB Atlas

DÃ©ployer sur Render ou Heroku

Variables .env :

MONGO_URI=...
JWT_SECRET=monsecret
PORT=5000


ğŸ’¡ Si tu veux, je peux te prÃ©parer tout le projet complet prÃªt Ã  exÃ©cuter avec commentaires ligne par ligne pour que tu nâ€™aies plus quâ€™Ã  le personnaliser et dÃ©ployer.
Veux-tu que je te fasse la version clÃ© en main ?

Vous avez ditÂ :
Ok veillez me prÃ©parer tout le projet au complet prÃªt Ã  exÃ©cuter avec commentaires ligne par ligne mais ajouter aussi les validateurs avec joi ok !
ChatGPT a ditÂ :

Super â€” je te fournis le projet complet, prÃªt Ã  exÃ©cuter, avec Joi pour la validation, JWT pour lâ€™authentification, bcrypt pour le hachage des mots de passe, une architecture claire (models / controllers / routes / middlewares / validators), et commentaires ligne par ligne pour que tu puisses tout comprendre.

âœ… Ce que tu vas recevoir ici : tous les fichiers essentiels (contenu Ã  copier dans ton projet).
âœ… AprÃ¨s avoir copiÃ© les fichiers, je te donne les commandes pour installer et lancer localement, puis un rappel pour le dÃ©ploiement sur Render / Atlas.

Arborescence recommandÃ©e (copie-colle)
gestion-taches/
â”œâ”€ config/
â”‚  â””â”€ db.js
â”œâ”€ controllers/
â”‚  â”œâ”€ auth.controller.js
â”‚  â”œâ”€ user.controller.js
â”‚  â””â”€ task.controller.js
â”œâ”€ middleware/
â”‚  â”œâ”€ auth.middleware.js
â”‚  â””â”€ error.middleware.js
â”œâ”€ models/
â”‚  â”œâ”€ User.js
â”‚  â””â”€ Task.js
â”œâ”€ routes/
â”‚  â”œâ”€ auth.routes.js
â”‚  â”œâ”€ user.routes.js
â”‚  â””â”€ task.routes.js
â”œâ”€ validators/
â”‚  â”œâ”€ auth.validator.js
â”‚  â””â”€ task.validator.js
â”œâ”€ .env.example
â”œâ”€ package.json
â”œâ”€ README.md
â””â”€ server.js


Important : crÃ©e un dossier gestion-taches, puis crÃ©e les fichiers suivants avec exactement ce contenu.

1) package.json

CrÃ©e ce fichier Ã  la racine.

{
  "name": "gestion-taches",
  "version": "1.0.0",
  "description": "API Gestion des TÃ¢ches d'une Ã‰quipe (Node.js, Express, MongoDB, JWT, Joi)",
  "main": "server.js",
  "scripts": {
    "dev": "nodemon server.js",
    "start": "node server.js"
  },
  "keywords": [],
  "author": "",
  "license": "MIT",
  "dependencies": {
    "bcryptjs": "^2.4.3",
    "cors": "^2.8.5",
    "dotenv": "^16.4.5",
    "express": "^4.18.2",
    "helmet": "^7.1.0",
    "joi": "^17.13.3",
    "jsonwebtoken": "^9.0.0",
    "mongoose": "^8.5.2",
    "morgan": "^1.10.0"
  },
  "devDependencies": {
    "nodemon": "^3.1.4"
  }
}

2) .env.example

Copie ce fichier en .env et remplace par tes valeurs (ne pas commiter .env).

PORT=5000
MONGO_URI=mongodb+srv://<USER>:<PASSWORD>@cluster0.example.mongodb.net/gestion_taches?retryWrites=true&w=majority
JWT_SECRET=ta_cle_secrete_trÃ¨s_longue
TOKEN_EXPIRES_IN=1d
CORS_ORIGIN=*

3) config/db.js

Connexion Mongoose centralisÃ©e.

// config/db.js
// Fichier central pour se connecter Ã  MongoDB via mongoose.

const mongoose = require('mongoose');

/**
 * connectDB: se connecte Ã  la base MongoDB.
 * @param {string} uri - chaÃ®ne de connexion MongoDB (depuis .env)
 */
async function connectDB(uri) {
  try {
    // mongoose.connect retourne une promesse ; on attend la connexion
    await mongoose.connect(uri);
    console.log('âœ… MongoDB connectÃ©');
  } catch (err) {
    // Si Ã©chec de connexion, on affiche et on arrÃªte l'application
    console.error('âŒ Erreur de connexion MongoDB :', err.message);
    process.exit(1);
  }
}

module.exports = { connectDB };

4) models/User.js

ModÃ¨le utilisateur (nom, email unique, mot de passe hachÃ©, rÃ´le).

// models/User.js
// SchÃ©ma Mongoose pour les utilisateurs

const mongoose = require('mongoose');

const userSchema = new mongoose.Schema({
  nom: {
    type: String,
    required: true,
    trim: true
  },
  email: {
    type: String,
    required: true,
    unique: true,   // Email unique
    lowercase: true,
    trim: true
  },
  motdepasse: {
    type: String,
    required: true
  },
  role: {
    type: String,
    enum: ['membre', 'admin'],
    default: 'membre'
  }
}, { timestamps: true });

// Export du modÃ¨le : 'User' -> collection 'users'
module.exports = mongoose.model('User', userSchema);

5) models/Task.js

ModÃ¨le tÃ¢che avec rÃ©fÃ©rence Ã  l'assignee (utilisateur).

// models/Task.js
// SchÃ©ma Mongoose pour les tÃ¢ches

const mongoose = require('mongoose');

const taskSchema = new mongoose.Schema({
  titre: {
    type: String,
    required: true,
    trim: true
  },
  description: {
    type: String,
    default: '',
    trim: true
  },
  priorite: {
    type: String,
    enum: ['Haute', 'Moyenne', 'Basse'],
    default: 'Moyenne'
  },
  statut: {
    type: String,
    enum: ['En cours', 'TerminÃ©e'],
    default: 'En cours'
  },
  assignee: {
    type: mongoose.Schema.Types.ObjectId,
    ref: 'User',   // RÃ©fÃ©rence au modÃ¨le User
    default: null
  },
  dateEcheance: {
    type: Date,
    default: null
  }
}, { timestamps: true });

module.exports = mongoose.model('Task', taskSchema);

6) validators/auth.validator.js

Validation Joi pour signup/login.

// validators/auth.validator.js
// Contient les schÃ©mas Joi pour l'inscription et la connexion

const Joi = require('joi');

// SchÃ©ma pour l'inscription
const signupSchema = Joi.object({
  nom: Joi.string().min(2).max(100).required().messages({
    'string.base': 'Le nom doit Ãªtre une chaÃ®ne',
    'string.empty': 'Le nom est requis',
    'string.min': 'Le nom doit faire au moins {#limit} caractÃ¨res',
  }),
  email: Joi.string().email().required().messages({
    'string.email': 'Email invalide',
    'string.empty': 'Email est requis'
  }),
  motdepasse: Joi.string().min(6).required().messages({
    'string.min': 'Le mot de passe doit contenir au moins {#limit} caractÃ¨res'
  })
});

// SchÃ©ma pour la connexion
const loginSchema = Joi.object({
  email: Joi.string().email().required(),
  motdepasse: Joi.string().required()
});

module.exports = { signupSchema, loginSchema };

7) validators/task.validator.js

Validation Joi pour crÃ©er / mettre Ã  jour une tÃ¢che.

// validators/task.validator.js
// SchÃ©mas Joi pour crÃ©er / mettre Ã  jour une tÃ¢che

const Joi = require('joi');

// SchÃ©ma crÃ©ation (titre requis)
const createTaskSchema = Joi.object({
  titre: Joi.string().min(2).max(200).required(),
  description: Joi.string().allow('').max(2000),
  priorite: Joi.string().valid('Haute', 'Moyenne', 'Basse'),
  statut: Joi.string().valid('En cours', 'TerminÃ©e'),
  assignee: Joi.string().hex().length(24).allow(null), // ObjectId ou null
  dateEcheance: Joi.date().iso().allow(null)
});

// SchÃ©ma update : au moins 1 champ
const updateTaskSchema = Joi.object({
  titre: Joi.string().min(2).max(200),
  description: Joi.string().allow('').max(2000),
  priorite: Joi.string().valid('Haute', 'Moyenne', 'Basse'),
  statut: Joi.string().valid('En cours', 'TerminÃ©e'),
  assignee: Joi.string().hex().length(24).allow(null),
  dateEcheance: Joi.date().iso().allow(null)
}).min(1);

module.exports = { createTaskSchema, updateTaskSchema };

8) controllers/auth.controller.js

Signup & login avec bcrypt + JWT. Commentaires ligne par ligne.

// controllers/auth.controller.js
// ContrÃ´leur pour l'inscription et la connexion

const User = require('../models/User');
const bcrypt = require('bcryptjs');
const jwt = require('jsonwebtoken');
const { signupSchema, loginSchema } = require('../validators/auth.validator');

// INSCRIPTION
exports.signup = async (req, res, next) => {
  try {
    // 1) Validation des donnÃ©es reÃ§ues
    const { error, value } = signupSchema.validate(req.body);
    if (error) {
      // Joi fournit details ; on renvoie 400
      return res.status(400).json({ message: error.details.map(d => d.message).join(' | ') });
    }

    const { nom, email, motdepasse } = value;

    // 2) VÃ©rifier si l'email existe dÃ©jÃ 
    const existing = await User.findOne({ email });
    if (existing) return res.status(400).json({ message: 'Email dÃ©jÃ  utilisÃ©' });

    // 3) Hacher le mot de passe (sÃ©curitÃ©)
    const salt = await bcrypt.genSalt(10);
    const hashed = await bcrypt.hash(motdepasse, salt);

    // 4) CrÃ©er l'utilisateur et le sauvegarder
    const user = new User({ nom, email, motdepasse: hashed });
    await user.save();

    // 5) RÃ©ponse : 201 Created
    res.status(201).json({ message: 'Utilisateur crÃ©Ã©', user: { id: user._id, nom: user.nom, email: user.email } });
  } catch (err) {
    next(err); // passage au middleware d'erreur
  }
};

// CONNEXION
exports.login = async (req, res, next) => {
  try {
    // 1) Validation
    const { error, value } = loginSchema.validate(req.body);
    if (error) return res.status(400).json({ message: error.details.map(d => d.message).join(' | ') });

    const { email, motdepasse } = value;

    // 2) Recherche utilisateur
    const user = await User.findOne({ email });
    if (!user) return res.status(400).json({ message: 'Email ou mot de passe invalide' });

    // 3) VÃ©rifier mot de passe
    const isValid = await bcrypt.compare(motdepasse, user.motdepasse);
    if (!isValid) return res.status(400).json({ message: 'Email ou mot de passe invalide' });

    // 4) GÃ©nÃ©rer token JWT (payload minimal)
    const payload = { id: user._id, role: user.role };
    const token = jwt.sign(payload, process.env.JWT_SECRET, { expiresIn: process.env.TOKEN_EXPIRES_IN || '1d' });

    // 5) RÃ©pondre avec token
    res.json({ message: 'Connexion rÃ©ussie', token });
  } catch (err) {
    next(err);
  }
};

9) controllers/user.controller.js

Gestion des membres (liste, dÃ©tail, supprimer). ProtÃ©gÃ©e par auth middleware (admin check optional).

// controllers/user.controller.js
const User = require('../models/User');

/**
 * Lister tous les utilisateurs
 * (dans une app rÃ©elle, restreindre cette route aux admins)
 */
exports.listUsers = async (req, res, next) => {
  try {
    const users = await User.find().select('-motdepasse').sort({ createdAt: -1 });
    res.json(users);
  } catch (err) {
    next(err);
  }
};

// RÃ©cupÃ©rer un utilisateur par id
exports.getUserById = async (req, res, next) => {
  try {
    const u = await User.findById(req.params.id).select('-motdepasse');
    if (!u) return res.status(404).json({ message: 'Utilisateur non trouvÃ©' });
    res.json(u);
  } catch (err) {
    next(err);
  }
};

// Supprimer un utilisateur (attention : en prod, vÃ©rifier droits)
exports.deleteUser = async (req, res, next) => {
  try {
    const deleted = await User.findByIdAndDelete(req.params.id);
    if (!deleted) return res.status(404).json({ message: 'Utilisateur non trouvÃ©' });
    res.json({ message: 'Utilisateur supprimÃ©' });
  } catch (err) {
    next(err);
  }
};

10) controllers/task.controller.js

CRUD tÃ¢ches + pagination + filtres (prioritÃ© / statut) + assignation. Commentaires dÃ©taillÃ©s.

// controllers/task.controller.js
const Task = require('../models/Task');
const { createTaskSchema, updateTaskSchema } = require('../validators/task.validator');
const mongoose = require('mongoose');

/**
 * CrÃ©er une tÃ¢che
 * POST /api/tasks
 */
exports.createTask = async (req, res, next) => {
  try {
    // Validation Joi
    const { error, value } = createTaskSchema.validate(req.body);
    if (error) return res.status(400).json({ message: error.details.map(d => d.message).join(' | ') });

    // On peut associer le crÃ©ateur si on le souhaite : req.user.id
    const task = new Task(value);
    await task.save();

    res.status(201).json(task);
  } catch (err) {
    next(err);
  }
};

/**
 * Lister les tÃ¢ches avec pagination et filtres
 * GET /api/tasks?page=1&limit=10&priorite=Haute&statut=En%20cours&assignee=ID
 */
exports.getTasks = async (req, res, next) => {
  try {
    // ParamÃ¨tres de query
    let { page = 1, limit = 10, priorite, statut, assignee, sortBy = 'createdAt', order = 'desc' } = req.query;
    page = parseInt(page);
    limit = Math.min(parseInt(limit), 100); // safeguard
    const skip = (page - 1) * limit;
    const sortOrder = order === 'asc' ? 1 : -1;

    // Construction du filtre dynamique
    const filter = {};
    if (priorite) filter.priorite = priorite;
    if (statut) filter.statut = statut;
    if (assignee && mongoose.Types.ObjectId.isValid(assignee)) filter.assignee = assignee;

    // ExÃ©cution des requÃªtes en parallÃ¨le
    const [items, total] = await Promise.all([
      Task.find(filter)
        .populate('assignee', 'nom email')      // remplace assignee par document user minimal
        .sort({ [sortBy]: sortOrder })
        .skip(skip)
        .limit(limit),
      Task.countDocuments(filter)
    ]);

    res.json({
      meta: {
        page,
        limit,
        total,
        totalPages: Math.ceil(total / limit)
      },
      data: items
    });
  } catch (err) {
    next(err);
  }
};

/**
 * RÃ©cupÃ©rer une tÃ¢che par id
 */
exports.getTaskById = async (req, res, next) => {
  try {
    const t = await Task.findById(req.params.id).populate('assignee', 'nom email');
    if (!t) return res.status(404).json({ message: 'TÃ¢che non trouvÃ©e' });
    res.json(t);
  } catch (err) {
    next(err);
  }
};

/**
 * Mettre Ã  jour une tÃ¢che
 * PUT /api/tasks/:id
 */
exports.updateTask = async (req, res, next) => {
  try {
    // Validation Joi (au moins 1 champ)
    const { error, value } = updateTaskSchema.validate(req.body);
    if (error) return res.status(400).json({ message: error.details.map(d => d.message).join(' | ') });

    const updated = await Task.findByIdAndUpdate(req.params.id, value, { new: true, runValidators: true });
    if (!updated) return res.status(404).json({ message: 'TÃ¢che non trouvÃ©e' });
    res.json(updated);
  } catch (err) {
    next(err);
  }
};

/**
 * Supprimer une tÃ¢che
 */
exports.deleteTask = async (req, res, next) => {
  try {
    const deleted = await Task.findByIdAndDelete(req.params.id);
    if (!deleted) return res.status(404).json({ message: 'TÃ¢che non trouvÃ©e' });
    res.json({ message: 'TÃ¢che supprimÃ©e' });
  } catch (err) {
    next(err);
  }
};

11) middleware/auth.middleware.js

VÃ©rifie le token JWT et injecte req.user. On peut ajouter contrÃ´le de role.

// middleware/auth.middleware.js
// Middleware pour protÃ©ger les routes nÃ©cessitant une authentification

const jwt = require('jsonwebtoken');

/**
 * authMiddleware - vÃ©rifie prÃ©sence et validitÃ© d'un JWT dans Authorization header
 * Header attendu : Authorization: Bearer <token>
 */
module.exports = function (req, res, next) {
  // RÃ©cupÃ¨re le header Authorization
  const authHeader = req.header('Authorization');
  if (!authHeader) return res.status(401).json({ message: 'Token manquant' });

  // Support "Bearer token" ou juste token
  const token = authHeader.startsWith('Bearer ') ? authHeader.split(' ')[1] : authHeader;

  if (!token) return res.status(401).json({ message: 'Token manquant' });

  try {
    // VÃ©rifie le token et rÃ©cupÃ¨re le payload
    const decoded = jwt.verify(token, process.env.JWT_SECRET);
    req.user = decoded; // ex: { id: ..., role: ... }
    next();
  } catch (err) {
    return res.status(401).json({ message: 'Token invalide' });
  }
};

12) middleware/error.middleware.js

Gestion dâ€™erreurs centralisÃ©e.

// middleware/error.middleware.js

module.exports = function (err, req, res, next) {
  console.error('Erreur attrapÃ©e :', err.message);
  const status = err.status || 500;
  res.status(status).json({
    success: false,
    message: err.message || 'Erreur serveur'
  });
};

13) routes/auth.routes.js

Routes signup & login.

// routes/auth.routes.js
const express = require('express');
const router = express.Router();
const authCtrl = require('../controllers/auth.controller');

// POST /api/auth/signup
router.post('/signup', authCtrl.signup);

// POST /api/auth/login
router.post('/login', authCtrl.login);

module.exports = router;

14) routes/user.routes.js

Gestion membres (protÃ©gÃ©e).

// routes/user.routes.js
const express = require('express');
const router = express.Router();
const userCtrl = require('../controllers/user.controller');
const auth = require('../middleware/auth.middleware');

// Toutes ces routes nÃ©cessitent d'Ãªtre authentifiÃ© (token)
router.get('/', auth, userCtrl.listUsers);
router.get('/:id', auth, userCtrl.getUserById);
router.delete('/:id', auth, userCtrl.deleteUser);

module.exports = router;

15) routes/task.routes.js

Routes tÃ¢ches (protÃ©ger selon besoin).

// routes/task.routes.js
const express = require('express');
const router = express.Router();
const taskCtrl = require('../controllers/task.controller');
const auth = require('../middleware/auth.middleware');

// Protection : toutes les routes nÃ©cessitent un token
router.post('/', auth, taskCtrl.createTask);
router.get('/', auth, taskCtrl.getTasks);
router.get('/:id', auth, taskCtrl.getTaskById);
router.put('/:id', auth, taskCtrl.updateTask);
router.delete('/:id', auth, taskCtrl.deleteTask);

module.exports = router;

16) server.js

Point dâ€™entrÃ©e : configuration, middlewares globaux, routes, connexion DB, dÃ©marrage.

// server.js
// Point d'entrÃ©e de l'application

require('dotenv').config();            // charge .env
const express = require('express');
const helmet = require('helmet');      // sÃ©curitÃ© headers
const cors = require('cors');          // gestion CORS
const morgan = require('morgan');      // logs HTTP

const { connectDB } = require('./config/db');
const errorHandler = require('./middleware/error.middleware');

// Routes
const authRoutes = require('./routes/auth.routes');
const userRoutes = require('./routes/user.routes');
const taskRoutes = require('./routes/task.routes');

const app = express();

// Middlewares globaux
app.use(helmet());
app.use(cors({ origin: process.env.CORS_ORIGIN || '*' })); // limiter en prod
app.use(morgan('dev'));
app.use(express.json()); // parse application/json

// Routes principales (prÃ©fixÃ©es)
app.use('/api/auth', authRoutes);
app.use('/api/users', userRoutes);
app.use('/api/tasks', taskRoutes);

// 404 si route non trouvÃ©e
app.use((req, res, next) => {
  res.status(404).json({ message: `Route ${req.originalUrl} introuvable` });
});

// Middleware gestion d'erreurs centralisÃ©
app.use(errorHandler);

// Connexion DB puis dÃ©marrage du serveur
const PORT = process.env.PORT || 5000;
connectDB(process.env.MONGO_URI).then(() => {
  app.listen(PORT, () => {
    console.log(`ğŸš€ Serveur dÃ©marrÃ© sur http://localhost:${PORT}`);
  });
});

17) README.md (exÃ©cution locale & dÃ©ploiement bref)

CrÃ©e un README pour instructions rapides.

# Gestion TÃ¢ches (API)

## Installation locale

1. Cloner le repo ou copier les fichiers.
2. `cd gestion-taches`
3. `npm install`
4. Copier `.env.example` en `.env` et remplir `MONGO_URI`, `JWT_SECRET`, etc.
5. Lancer en dev :


npm run dev

L'API Ã©coute sur `http://localhost:5000` (si PORT=5000).

## Endpoints principaux

- `POST /api/auth/signup` - body: { nom, email, motdepasse }
- `POST /api/auth/login` - body: { email, motdepasse } -> renvoie token
- `GET /api/tasks` - liste paginÃ©e/filter (requiert header Authorization)
- `POST /api/tasks` - crÃ©er tÃ¢che (requiert token)
- `PUT /api/tasks/:id` - modifier
- `DELETE /api/tasks/:id` - supprimer
- `GET /api/users` - lister les utilisateurs (requiert token)

## DÃ©ploiement (bref)
1. CrÃ©er cluster MongoDB Atlas et rÃ©cupÃ©rer `MONGO_URI`.
2. Push sur GitHub.
3. CrÃ©er un service Web sur Render :
   - Build: `npm install`
   - Start: `npm start`
   - Add Environment variables (MONGO_URI, JWT_SECRET, PORT, CORS_ORIGIN)
4. DÃ©ployer et tester l'URL fournie par Render.

> Note : pour les images/fichiers en prod, Ã©vite stockage local ; utiliser S3/Cloudinary.

âœ… Etapes pour lancer localement (rÃ©capitulatif)

CrÃ©e dossier gestion-taches et tous les fichiers ci-dessus.

cd gestion-taches

npm install

Copie .env.example â†’ .env puis complÃ¨te avec ta chaÃ®ne MONGO_URI (Atlas) et JWT_SECRET.

Lancer en dev :

npm run dev


Tester avec Postman / Thunder Client :

Inscription : POST /api/auth/signup body JSON { "nom": "Alice", "email": "a@x.com", "motdepasse": "secret" }

Connexion : POST /api/auth/login body { "email": "...", "motdepasse": "..." } â†’ rÃ©cupÃ¨re token

Utiliser header Authorization: Bearer <token> pour routes protÃ©gÃ©es.

âœ… Tests rapides (exemples Postman)

Inscription

URL: POST http://localhost:5000/api/auth/signup

Body JSON:

{ "nom": "Jean", "email": "jean@example.com", "motdepasse": "azerty123" }


Connexion

URL: POST http://localhost:5000/api/auth/login

Body JSON:

{ "email": "jean@example.com", "motdepasse": "azerty123" }


RÃ©ponse : { message: 'Connexion rÃ©ussie', token: '...' }

CrÃ©er TÃ¢che

URL: POST http://localhost:5000/api/tasks

Headers: Authorization: Bearer <token>

Body JSON:

{ "titre": "PrÃ©parer rÃ©union", "description": "PrÃ©parer slides", "priorite": "Haute" }


Lister tÃ¢ches (pagination et filtres)

URL: GET http://localhost:5000/api/tasks?page=1&limit=10&priorite=Haute&statut=En%20cours

Si tu veux, je peux gÃ©nÃ©rer un archive ZIP prÃªt Ã  tÃ©lÃ©charger (si tu veux que je lâ€™envoie ici je peux te fournir le contenu via steps), ou je peux directement ajouter lâ€™auth + rÃ´le admin (par ex : empÃªcher suppression dâ€™utilisateur sauf admin), ou ajouter tests avec Jest/Supertest.

Dis-moi :

Tu veux que jâ€™ajoute la vÃ©rification isAdmin pour certaines routes ?

Tu veux que jâ€™intÃ¨gre lâ€™upload (ex : piÃ¨ce jointe pour tÃ¢che) maintenant ?

Ou on passe directement au dÃ©ploiement Render + Atlas ensemble (je te guide Ã©tape par Ã©tape) ?

ChatGPT peut faire des erreurs. Envisagez de vÃ©r